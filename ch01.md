# Capítulo 01: O Que Estamos Fazendo?

## Introduções

Olá! Meu nome é Professor Franklin Frisby. Prazer em conhecê-lo. Ao que parece, fui encarregado de lhe ensinar um pouco sobre programação funcional. Mas e você, como está? Espero que esteja ao menos um pouco familiarizado com JavaScript. Talvez você tenha alguma experiência com Programação Orientada a Objetos, e se considere um desenvolvedor pragmático. Se sim, ótimo! Você não precisa ter um PhD em Entomologia para ler esse livro - apenas saber achar e matar alguns bugs.

 Não vou assumir que você tem qualquer conhecimento prévio em programação funcional. Assumo, no entanto, que você já tenha lidado com algumas das situações complicadas que surgem ao lidar com mutação de variáveis, efeitos colaterais irrestritos e design sem princípios. Sigamos em frente.

 O propósito deste capítulo é lhe dar uma ideia do que buscamos quando escrevemos programas funcionais. Para que compreenda os próximos capítulos, precisamos entender o que faz um programa ser *funcional*. Caso contrário, vamos acabar escrevendo de maneira desnorteada, evitando objetos a todo custo - uma ideia com pouco futuro, para dizer o mínimo. Precisamos de um norte para nos guiar quando surgirem os problemas complexos.

 Sabemos que existem alguns princípios gerais de programação - vários acrônimos que pretendem nos ajudar a atravessar os momentos difíceis: DRY (Don't Repeat Yourself, ou Não Se Repita), YAGNI (Ya Ain't Gonna Need It, ou Você Não Vai Precisar Disso), Separação de Responsabilidades, etc.

 Não vou continuar listando todas as regras que ouvi ao longo dos anos... O ponto aqui é que elas continuam válidas num programa funcional, ainda que sejam meramente tangenciais ao nosso objetivo final. O que quero que você absorva agora, antes que continuemos, é a nossa intenção quando batemos os dedos nas teclas; nossa Xanadu funcional.

<!--BREAK-->

## Desencanto

Comecemos com um toque de insanidade. Aqui está um app sobre gaivotas. Quando uma revoada de pássaros se une à outra para formar uma revoada maior, e quando procriam, elas aumentam o número de gaivotas com quem estão procriando. Veja bem, esse código não pretende ser "bom" código Orientado a Objetos, mas apenas uma pincelada sobre os perigos do nosso approach baseado em atribuição à variáveis. Observe:

```js
class Revoada {
  constructor(n) {
    this.gaivotas = n;
  }

  unir(outra) {
    this.gaivotas += outra.gaivotas;
    return this;
  }

  procriar(outra) {
    this.gaivotas = this.gaivotas * outra.gaivotas;
    return this;
  }
}

const revoadaA = new Revoada(4);
const revoadaB = new Revoada(2);
const revoadaC = new Revoada(0);
const resultado = revoadaA
  .unir(revoadaC)
  .procriar(revoadaB)
  .unir(revoadaA.procriar(revoadaB))
  .gaivotas;
// 32
```

Quem diabos teclaria tal abominação? É impossível modelar mentalmente o estado interno que é alterado contínuamente. E pelo amor de deus, a resposta está incorreta! Deveria ser `16`, mas a `revoadaA` acabou permanentemente alterada no processo. Coitada da `revoadaA`. Isso é pura anarquia! Aritmética selvagem!

Se você não entende esse programa, não há problema - eu também não. Lembre-se apenas que estado mutável é difícil de manter em mente, mesmo em um exemplo pequeno.

Vamos tentar novamente, dessa vez com uma estratégia funcional:

```js
const unir = (revoadaX, revoadaY) => revoadaX + revoadaY;
const procriar = (revoadaX, revoadaY) => revoadaX * revoadaY;

const revoadaA = 4;
const revoadaB = 2;
const revoadaC = 0;
const resultado = unir(
  procriar(
    revoadaB, 
    unir(revoadaA, revoadaC)
  ), 
  procriar(revoadaA, revoadaB)
);
// 16
```

Pelo menos dessa vez chegamos à resposta certa. Com menos código. As funções dentro de funções não são fáceis de ler...(remediaremos este problema no capítulo 5). Está melhor, mas vamos ir um pouco além. Nomes nos dão poder sobre as coisas, e portanto nomear corretamente sempre traz benefícios. Olhando de perto para nossas funções `unir` e `procriar`, vemos que estamos lidando com nossas velhas amigas adição (`unir`) e multiplicação (`procriar`). 

Não há nada de especial sobre essas funções além de seus nomes. Renomearemos nossas funções para `multiplicar` e `somar` para revelar suas verdadeiras identidades.

```js
const somar = (x, y) => x + y;
const multiplicar = (x, y) => x * y;

const revoadaA = 4;
const revoadaB = 2;
const revoadaC = 0;
const resultado = somar(
  multiplicar(
    revoadaB, 
    somar(revoadaA, revoadaC)
  ), 
  multiplicar(revoadaA, revoadaB)
);
// 16
```
E com isso, podemos aplicar o conhecimento dos antigos:

```js
// associatividade
// (x + y) + z === x + (y + z)
somar(somar(x, y), z) === somar(x, somar(y, z));

// comutatividade
// x + y === y + x
somar(x, y) === somar(y, x);

// identidade
// x + 0 === x
somar(x, 0) === x;

// distributividade
// x * (y + z) === (x * y) + (x * z)
multiplicar(x, somar(y, z)) === somar(multiplicar(x, y), multiplicar(x, z));
```

Sim, as fiéis propriedades matemáticas virão a calhar. Não se preocupe caso não tenha se lembrado delas imediatamente - para muitos de nós, faz algum tempo que aprendemos sobre essas leis da aritmética. Vejamos se podemos utilizar essas propriedades para simplificar nosso pequeno programa sobre gaivotas. 

```js
// Originalmente
somar(
  multiplicar(
    revoadaB, 
    somar(revoadaA, revoadaC)
  ),
  multiplicar(revoadaA, revoadaB)
);

// Apliquemos a lei da identidade para remover a soma desnecessária
// somar(revoadaA, revoadaC) === revoadaA, visto que revoadaC === 0.
somar(
  multiplicar(revoadaB, revoadaA), 
  multiplicar(revoadaA, revoadaB)
);

// Agora podemos aplicar a lei da distributividade
multiplicar(
  revoadaB, 
  somar(revoadaA, revoadaA)
);
```

Brilhante! Não tivemos que escrever código algum além da nossa simples funções. Definimos no nosso código `somar` e `multiplicar`, mas certamente não seria necessário escrevê-las - alguma library nos proveria com as mesmas.

Você pode estar pensando "que sujo de sua parte escolher um exemplo tão matemático", ou "programas de verdade não são tão simples e não podem ser resolvidos de tal maneira". Escolhi este exemplo pois a maioria de nós sabe algo sobre adição e multiplicação, o que nos dá um contexto inicial prático.

Não se desespere - ao longo deste livro, veremos salpicadas de teoria de categorias, teoria de conjuntos e cálculo lambda. Armados desses conceitos, escreveremos exemplos próximos da realidade e atingiremos o mesmo nível de simplicidade e resultado do nosso humilde exemplo das gaivotas. E você não precisa ter um bacharelado em matemática para tal - tudo fluirá de maneira fácil e natural, como se você estivesse usando um framework "normal" ou a API de uma biblioteca qualquer.

Pode lhe surpreender que consigamos escrever programas completos, prontos para produção, similares ao código acima. Programas que possuem propriedades e leis. Programas que são curtos, mas fáceis de compreender. Programas que não reinventam a roda a cada módulo. Ausência de leis é ótimo caso seja um criminoso, mas, neste livro, apreciaremos e obedeceremos as leis da matemática.

Utilizaremos uma teoria onde cada peça se encaixa na próxima naturalmente. Representaremos nossos problemas específicos como composições de blocos genéricos (como LEGO) e exploraremos suas propriedades para benefício próprio. Será necessário um pouco mais de disciplina do que o viés "vale tudo" de programação imperativa (veremos a definição precisa de "imperativa" mais tarde, mas por enquanto pense aqui em qualquer coisa que não seja funcional). A recompensa irá lhe surpreender além do que possa imaginar.

Vimos nossa Estrela do Norte de relance, mas ainda temos alguns conceitos a assimilar antes de continuar nossa jornada.

[Capítulo 02: Funções de Primeira Classe](ch02.md)
