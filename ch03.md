# Capítulo 03: Felicidade Pura com Funções Puras

## Nirvana

Logo de início, precisamos entender a ideia de uma função pura.

>Uma função pura é uma função que, dado um mesmo argumento, sempre produzirá o mesmo resultado - sem efeitos colaterais observáveis.

Veja, por exemplo, `slice` e `splice`. São duas funções que fazem exatamente a mesma coisa, mas de maneiras completamente diferentes. Podemos dizer que `slice` é *pura*, pois sempre retorna o mesmo resultado se receber o mesmo argumento, sem exceções. Por outro lado, `splice` mexe com seu array - e ele nunca mais será o mesmo (o que, aliás, é um efeito colateral observável).

```js
const xs = [1,2,3,4,5];

// puro
xs.slice(0,3); // [1,2,3]

xs.slice(0,3); // [1,2,3]

xs.slice(0,3); // [1,2,3]


// impuro
xs.splice(0,3); // [1,2,3]

xs.splice(0,3); // [4,5]

xs.splice(0,3); // []
```

Em programação funcional, não gostamos de funções bagunceiras como `splice`, que *mudam* seus dados. Queremos funções confiáveis, que retornam o mesmo resultado sempre, não funções que causam um estrago por onde passam.

Outro exemplo:

```js
// impuro
let minimo = 21;
const verificarIdade = idade => idade >= minimo;

// puro
const verificarIdade = (idade) => {
  const minimo = 21;
  return idade >= minimo;
};
```

Na versão impura, `verificarIdade` depende da variável *mutável* `minimo` para determinar o resultado. Em outras palavras, depende do estado de um sistema externo. Queremos evitar o aumento da [carga cognitiva](https://pt.wikipedia.org/wiki/Esfor%C3%A7o_cognitivo) que acontece quando dependemos de um ambiente externo.

Pode não parecer tão danoso nesse exemplo, mas essa dependência em *estado* é um dos maiores contribuintes para complexidade sistêmica (http://curtclifton.net/papers/MoseleyMarks06a.pdf). Esse modo de `verificarIdade` pode retornar diferentes resultados de acordo com fatores externos aos argumentos - fato que não só disqualifica a função de ser pura, mas também nos deixa um passo mais próximo da insanidade quando temos que debugar programas.

A sua versão pura, no entanto, é completamente auto-suficiente. Nela, podemos fazer com que `minimo` seja *imutável*, o que preserva a pureza da função, visto que o estado nunca muda. Para fazer isso, precisamos congelar um objeto.

```js
// se já usou React com Redux, ou algo similar, talvez já tenha visto o termo "estado imutável"?
const estadoImutavel = Object.freeze({ minimo: 21 });
```

## Efeitos Colaterais Incluem...

Vejamos mais sobre efeitos e efeitos colaterais, para afiar nossa intuição. O que há de tão ruim em *efeitos colaterais* mencionados na definição de *função pura*? Vamos usar a palavra *efeito* para descrever qualquer coisa que acontece durante a computação do código além do cálculo do resultado (o computador esquentar, por exemplo). 

Não há nada inerentemente ruim sobre efeitos, e utilizaremos efeitos com frequência nos próximos capítulos. É a parte do *colateral* que tem conotações negativas. Água por si só não deixa ninguém doente - é a água *parada* que proporciona terreno fértil aos mosquitos da dengue. Garanto-lhe que efeitos *colaterais* proporcionam, de maneira similar, terreno fértil aos bugs nos seus programas.

>Um *efeito colateral* é uma mudança no estado do sistema ou *interação observável* com o mundo externo que ocorre durante a computação de um resultado.

Efeitos colaterais incluem, mas não são limitados a

  * interações com arquivos do sistema
  * interações com um banco de dados
  * execução de requisições HTTP
  * mudanças de estado
  * prints ao terminal / geração de logs
  * interação com elementos da DOM
  * interação com o estado do sistema

E a lista poderia ir além. Qualquer interação com o mundo externo à uma função é um efeito colateral, fato que pode fazê-lo questionar sobre a utilidade prática de programação funcional. Na filosofia da programação funcional, efeitos colaterais são causa primária do comportamento incorreto de um programa.

Para acalmar seus nervos: não é que estamos proibidos de utilizar efeitos, mas sim que queremos segregar efeitos e executá-los de maneira controlada. Aprenderemos métodos para fazer isso quando chegarmos em [funtors](https://pt.wikipedia.org/wiki/Functor) e [mônadas](https://pt.wikipedia.org/wiki/M%C3%B3nade_(teoria_das_categorias)), mas, por enquanto, vamos simplesmente tentar separar essas maçãs podres das nossas maçãs puras e saudáveis.

Efeitos colaterais disqualificam uma função de ser *pura*. Faz sentido: funções puras, por definição, retornam o mesmo resultado quando recebem o mesmo argumento, o que é impossível de garantir quando o mundo externo pode alterar nosso cálculo.

Observe atentamente o porquê de batermos na tecla do "mesmo resultado para um mesmo argumento". Prepare-se, vamos mergulhar fundo na matemática da 7ª série.

## Matemática da 7ª Série

De acordo com o (brasil escola)[https://brasilescola.uol.com.br/o-que-e/matematica/o-que-e-funcao.htm]:

> Função é uma regra que relaciona cada elemento de um conjunto a um único elemento de outro conjunto

Em outras palavras, é só uma relação entre dois valores: o argumento e o resultado. Ainda que cada argumento "mapeie" para exatamente um resultado, o resultado não necessariamente tem que ser único de acordo com o argumento. Podemos ver abaixo um diagrama de uma função perfeitamente válida mapeando `x` a `y`:

<img src="images/function-sets.gif" alt="function sets" />(https://www.mathsisfun.com/sets/function.html)

Em contraste, o diagrama a seguir mostra uma relação que *não é* uma função, visto que o argumento `5` aponta para vários resultados.

<img src="images/relation-not-function.gif" alt="relation not function" />(https://www.mathsisfun.com/sets/function.html)

Funções podem ser descritas como um conjunto de pares com a posição (argumento, resultado): `[(1, 2), (3, 6), (5, 10)]` (Parece que essa função dobra o seu argumento e retorna o valor dobrado).

Ou como uma tabela:
<table> <tr> <th>Argumento</th> <th>Resultado</th> </tr> <tr> <td>1</td> <td>2</td> </tr> <tr> <td>2</td> <td>4</td> </tr> <tr> <td>3</td> <td>6</td> </tr> </table>

Ou até mesmo como um gráfico, com `x` como argumento e `y` como resultado:

<img src="images/fn_graph.png" width="300" height="300" alt="function graph" />


Não há necessidade de detalhes de implementação se o argumento dita o resultado. Como funções são simplesmente projeções, "mapas", que levam de argumento à resultado,  poderíamos simplesmente escrever um objeto com argumentos como chaves e resultados como valores - chamaríamos a nossa função com `[]` ao invés de `()`.

```js
const minuscula = {
  A: 'a',
  B: 'b',
  C: 'c',
  D: 'd',
  E: 'e',
  F: 'f',
};
minuscula['C']; // 'c'

const numeroPrimo = {
  1: false,
  2: true,
  3: true,
  4: false,
  5: true,
  6: false,
};
numeroPrimo[3]; // true
```

Obviamente queremos calcular ao invés de escrever tudo à mão, mas o exemplo serve pra ilustrar uma maneira diferente de entender funções. (Você pode estar se perguntando "mas e funções com mais de um argumento?". De fato, do ponto de vista matemático, esse é um detalhe inconveniente. Por enquanto, vamos só juntar todos eles num array ou objeto, e este será o nosso `argumento`. Quando aprendermos sobre *currying*, vamos ver como escrever funções que são exatamente como funções matemáticas.)

Agora, a revelação dramática: Funções puras *são* funções matemáticas, e programação *funcional* é sobre elas. Programar com esses anjinhos nos dá imensas recompensas. Algumas razões que nos fazem ir tão longe para preservar a pureza do nosso código:

## O Argumento Pela Pureza

### Cacheável

Para começo de conversa, funções puras *sempre* podem ser cacheadas de acordo com seus argumentos. Geralmente isso é feito com uma técnica chamada "memoização":

```js
const quadrado = memoizar(x => x * x);

quadrado(4); // 16, calculado

quadrado(4); // 16, retorna o cache do argumento 4

quadrado(5); // 25, calculado

quadrado(5); // 25, retorna o cache do argumento 5
```

Segue uma versão simplificada, mas saiba que existem versões muito mais robustas por aí.

```js
const memoizar = (fn) => {
  const cache = {};

  return (...args) => {
    const chaveArg = JSON.stringify(args);
    cache[chaveArg] = cache[chaveArg] || fn(...args);
    return cache[chaveArg];
  };
};
```

Uma observação interessante é que sempre é possível transformar funções impuras em funções puras, simplesmente atrasando a computação:

```js
const requisicaoHttpPura = memoizar(
  (url, params) => () =>
      $.getJSON(url, params)
);
```

Veja que nós não executamos a requisição HTTP - na verdade, retornamos uma função que executará a requisição quando for chamada. Essa função é pura, pois sempre retornará o mesmo resultado para o mesmo argumento: a função que fará a requisição HTTP de acordo com a `url` e os `params`.

Nossa função `memoizar` funciona, apenas não retorna o resultado da requisição HTTP, mas sim a função que fará a requisição.

Isso ainda não é tão útil, mas aprenderemos alguns truques em breve que aliviarão essa inutilidade. O resumo da ópera é que podemos cachear qualquer função pura, não importa o quão destrutiva ela parece ser.

### Portátil / Auto-documentada

Funções puras são completamente auto-contidas. Tudo que ela precisa, ela tem. Pare um segundo para digerir isso...Não é muito bom? Fica muito claro quais são as dependências da função, e portanto mais fácil de ver e entender - nada de sujo é varrido para debaixo do tapete.

```js
// impuro
const registrar = (atrs) => {
  const usuario = salvarUsuario(atrs);
  darBoasVindas(usuario);
};

// puro
const registrar = (ServiçoDb, ServiçoEmail, atrs) => () => {
  const usuario = salvarUsuario(ServiçoDb, atrs);
  darBoasVindas(ServiçoEmail, user);
};
```

O exemplo demonstra que a função pura é honesta sobre suas dependências - ela nos diz exatamente o que ela pretende fazer. Só de olhar sua *assinatura*, já vemos que vai utilizar `ServiçoDb`, `ServiçoEmail` e `atrs`, o que nos diz muito. 

Mais à frente, veremos como escrever funções similares, puras, mas sem o truque de postergar a computação. Ainda assim, deve ter ficado claro que a função pura é muito mais informativa do que a versão impura (que só deus sabe o que vai fazer).

Outro detalhe é que somos forçados a "injetar" nossas dependências, ou passá-las como argumentos, o que faz nosso app ser muito mais flexível - afinal, parametrizamos nosso cliente de banco de dados, emails, etc (também veremos uma maneira de deixar isso menos chato do que parece). Se quisermos trocar nosso serviço de banco de dados, só temos que passar a versão nova para as funções que precisam dele. Se acabarmos escrevendo um app similar, e queremos reutilizar nossa confiável função, simplesmente passamos o `ServiçoDb` ou `ServiçoEmail` que tivermos nesse novo projeto.

No contexto de JavaScript, portabilidade tem valor: Podemos serializar e enviar nossas funções através de um socket, ou rodar nossas funções em web workers. Portabilidade é extremamente útil.

Diferentemente dos métodos e procedimentos de programação imperativa, enraizados completamente no seu ambiente via estado, dependências e efeitos disponíveis, funções puras podem rodar aonde desejarmos.

Qual foi a última vez que você copiou um *método* num novo aplicativo? Uma das minhas frases favoritas é do criador de [Erlang](https://github.com/erlang/otp), (Joe Armstrong)[https://en.wikipedia.org/wiki/Joe_Armstrong_(programmer)]: "O problema com linguagens orientadas a objetos é todo esse ambiente implícito que elas carregam por todo lugar. Você queria uma banana, mas o que você conseguiu foi um gorila segurando uma banana... e toda a selva junto".[^1]

[^1]: Tradução minha.

### Testável

Em seguida, podemos perceber que funções puras facilitam, e muito, testar seu código. Não precisamos "mockar" um gateway de pagamento "real" ou fazer um setup e `assert` do estado do mundo após cada teste. 
Simplesmente passamos argumentos à funções e fazemos `assert` nos resultados.

De fato, a comunidade de programação funcional é pioneira em ferramentas de teste que podem metralhar nossas funções com argumentos gerados automaticamente, e então `assert` que as propriedades dos resultados estão corretas. É fora do escopo desse livro, mas recomendo que dê uma pesquisada sobre *QuickCheck* - uma ferramenta de testes que é feita para um ambiente puramente funcional.

### Razoável

Muitos acreditam que a maior recompensa de trabalhar com funções puras é *transparência referencial*. Um pedaço de código é referencialmente transparente quando pode ser substituído pelo valor que computa, sem alterar o comportamento do programa.

Como funções puras não podem ter efeitos colaterais, elas podem influenciar o comportamento de um programa *apenas* através dos seus resultados. Além disso, como os resultados podem ser calculados de maneira confiável utilizando apenas os argumentos dados, funções puras sempre preservam transparência referencial. Um exemplo deve esclarecer:


```js
const { Map } = require('immutable');

// Abreviações: jog = jogador, agr = agressor
const joao = Map({ nome: 'Joao', hp: 20, time: 'vermelho' });
const michael = Map({ nome: 'Michael', hp: 20, time: 'verde' });
const diminuirHP = jog => jog.set('hp', jog.get('hp') - 1);
const mesmoTime = (jog1, jog2) => jog1.get('time') === jog2.get('time');
const atacar = (agr, alvo) => (mesmoTime(agr, alvo) ? alvo : diminuirHP(alvo));

atacar(joao, michael); // Map({ nome:'Michael', hp:19, time: 'green' })
```

`diminuirHP`, `mesmoTime` and `atacar` são todas funções puras, e portanto transparentes referencialmente. Podemos usar uma técnica chamada *raciocínio equacional*, aonde substituímos "igual por igual" para entender o código. É como se computássemos o resultado manualmente. Utilizando transparência referencial, vamos brincar um pouco com esse código.

Primeiro, vamos deixar a função `mesmoTime` *inline*.

```js
const atacar = (agr, alvo) => (agr.get('time') === alvo.get('time') ? alvo : diminuirHP(alvo));
```

Como nossos dados são imutáveis, podemos simplesmente substituir mentalmente os times pelo seu valor verdadeiro.

```js
const atacar = (agr, alvo) => ('vermelho' === 'verde' ? alvo : diminuirHP(alvo));
```

Nesse caso, a verificação é `false`, então podemos remover todo um ramo computacional.

```js
const atacar = (agr, alvo) => diminuirHP(alvo);
```

E se deixarmos `diminuirHP` inline, veremos que, nesse caso, atacar simplemente diminui o `hp` em 1.

```js
const atacar = (agr, alvo) => alvo.set('hp', alvo.get('hp') - 1);
```

A possibilidade de raciocinar sobre código dessa maneira facilita refatoramentos, além do entendimento geral do código. De fato, usamos essa exata técnica para refatorar nosso programa de gaivotas. Aplicamos raciocínio equacional para tirar proveito das propriedades de adição de multiplicação. Veremos essa técnica várias vezes ao longo deste livro.

### Paralelização

Finalmente, o golpe de misericódia: Sempre podemos executar funções puras em paralelo, já que elas não necessitam de acesso à memória compartilhada e não podem, por definição, ter uma condição de corrida devido à algum efeito colateral (como duas funções que manipulam uma linha de um banco de dados, por exemplo).

É uma possibilidade que existe tanto no lado do servidor, com threads ou [worker threads](https://nodejs.org/api/worker_threads.html), como no navegador com web workers, ainde que no momento essas funcionalidades sejam pouco exploradas.


## Em Resumo

Vimos o que são funções puras e porque nós, programadores funcionais, acreditamos que elas são o máximo. De agora em diante, escreveremos todas as nossas funções de maneira pura. Eventualmente precisaremos de algumas ferramentas extras para nos ajudar, mas, por enquanto, vamos simplesmente segregar nossas funções impuras do resto do nosso código puro.

Escrever programas com funções puras é um pouco mais chato sem essas ferramentas extras. Teremos que passar dados de lá para cá, não podemos modificar estado, sem falar em utilizar efeitos. Como alguém consegue ser tão masoquista a ponto de programar assim? Veremos uma técnica que começará a aliviar a dor: *curry*.

[Capítulo 04: Currying](ch04.md)
