# Capítulo 02: Funções de Primeira Classe

## Uma Breve Revisão
Quando dizemos que funções são "de primeira classe", o que queremos dizer é que elas são como qualquer outra coisa... ou seja, uma "classe" normal. Podemos tratar funções como qualquer outro tipo de dado e não há nada de especial sobre elas - podem ser inseridas em arrays, passadas como parâmetros para outras funções, atribuídas à variáveis e etc.

Isso é o ABC de JavaScript, mas vale a lembrança - especialmente pois uma rápida busca por código no github revela a evasão coletiva deste conceito. Vamos inventar um exemplo? Vamos.

```js
const oi = nome => `Oi ${nome}`;
const cumprimentar = nome => oi(nome);
```

Aqui, a função anônima que embrulha `oi` em `cumprimentar` é completamente redundante. Por quê? Porque funções são *invocáveis* em JavaScript. Quando `oi` é seguido por `()`, a função será aplicada e retornará um valor. Quando não é seguido por `()`, simplesmente retornará a função em si. Confira:

```js
oi; // nome => `Oi ${nome}`
oi("jonas"); // "Oi jonas"
```

Como `cumprimentar` simplesmente chama `oi` com o mesmo argumento, poderíamos escrever:

```js
const cumprimentar = oi;
cumprimentar("joão"); // "Oi joão"
```

Em outras palavras, `oi` já é uma função que espera um argumento, então porque diabos escreveríamos uma função que chama `oi` com o mesmo argumento? Não faz sentido algum! É como usar seu casaco mais pesado no meio de Janeiro só para ligar o ar condicionado enquanto toma sorvete.

Além de verborrágico, é uma prática ruim envolver uma função com outra simplesmente para postergar a computação (veremos a razão em breve, mas tem a ver com manutenção).

Um entendimento sólido desse fato é crítico para que continuemos, então vamos examinar mais alguns exemplos escavados das profundezas de bibliotecas npm. 

```js
// ignorante
const buscarDoServidor = callback => getJSON(json => callback(json));

// iluminado
const buscarDoServidor = getJSON;
```

O mundo está cheio de código como esse. Veja a equivalência:

```js
// essa linha
getJSON(json => callback(json));

// é a mesma coisa que essa linha
getJSON(callback);

// então, refatorando `buscarDoServidor`
const buscarDoServidor = callback => getJSON(callback);

// ...que é equivalente a isto
const buscarDoServidor = getJSON; // <-- olha mãe, sem ()'s
```

E é assim que se faz. Mais uma vez, para que fique claro porque sou tão chato.

```js
const ControladorBlog = {
  index(posts) { return Views.index(posts); },
  mostrar(post) { return Views.mostrar(post); },
  criar(attrs) { return Db.criar(attrs); },
  atualizar(post, attrs) { return Db.atualizar(post, attrs); },
  destruir(post) { return Db.destruir(post); },
};
```

Esse controlador é 99% penduricalhos. Podemos reescrever dessa maneira:

```js
const ControladorBlog = {
  index: Views.index,
  mostrar: Views.mostrar,
  criar: Db.criar,
  atualizar: Db.atualizar,
  destruir: Db.destruir,
};
```

... ou simplesmente jogar tudo fora, já que ele não faz nada além de juntar funções prontas.

## Por que Utilizar Funções De Primeira Classe?

Ok, vamos destrinchar as razões para utilizar funções da maneira acima. Como vimos em `buscarDoServidor` e `ControladorBlog`, é muito fácil escrever camadas de distração que não adicionam valor algum ao código e aumentam a quantidade de código redundante que temos que manter.

Além disso, toda vez que alteramos nossas funções embrulhadas, o embrulho também deve ser alterado.

```js
httpGet('/post/2', json => renderizarPost(json));
```

Se `httpGet` fosse alterada para emitir um possível `err`, precisaríamos ajustar a nossa "cola".

```js
// precisamos alterar todos os usos de httpGet no nosso app e explicitamente passar err
httpGet('/post/2', (json, err) => renderizarPost(json, err));
```

Caso tívessemos escrito nosso código utilizando funções de primeira classe, pouparíamos nossos dedos:

```js
// renderizarPost é chamada dentro de httpGet com quantos argumentos precisar
httpGet('/post/2', renderPost);
```

Além da remoção de funções desnecessárias, temos mais uma razão: nomear argumentos. Nomes são sempre problemáticos, afinal cada nome dado cria a possibilidade de um nome mal-dado - especialmente conforme a base de código envelhece e os requerimentos mudam.

Ter múltiplos nomes para o mesmo conceito é uma fonte comum de confusão em projetos. Não apenas isso, mas se perde a chance de escrever código genérico. No exemplo abaixo, as duas funções fazem exatamente a mesma coisa, mas uma delas parece ser muito mais genérica e reutilizável.

```js
// específica
const artigosValidos = artigos =>
  artigos.filter(artigo => artigo !== null && artigo !== undefined);

// reutilizável
const compactar = xs => 
  xs.filter(x => x !== null && x !== undefined);
```

Utilizando nomes específicos, acabamos nos "amarrando" aos nossos dados (nesse caso `artigos`). De fato, nomes são causa frequente da reinvenção de rodas.

Devo mencionar que, assim como em Programação Orientada a Objetos em JavaScript, sempre devemos ficar atentos à `this` nos mordendo na jugular. Se uma função utiliza `this` e nós tentamos utilizá-la em primeira classe, somos sujeitos à ira dessa terrível abstração.

```js
const fs = require('fs');

// aterrorizante
fs.readFile('sexta_feira_treze.txt', Db.save);

// não tão aterrorizante
fs.readFile('sexta_feira_treze.txt', Db.save.bind(Db));
```

Uma vez que está vinculado à si mesmo, `Db` pode acessar livremente seu lixo de código prototípico. Evite `this` ao máximo. Não há razão alguma para utilizar `this` quando escrevemos código funcional. De toda maneira, quando lidar com outras bibliotecas, talvez você tenha que acomodar a loucura do mundo externo.

Alguns podem argumentar que `this` é necessário para otimizar nossos programas. Se você é um micro-otimizador, favor fechar este livro. Se não conseguir seu dinheiro de volta, talvez consiga trocá-lo por alguns insetos.

Dito isso, vamos em frente.

[Capítulo 03: Felicidade Pura com Funções Puras](ch03.md)
